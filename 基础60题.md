# 基础60题

## 第一题

```c++
#define _CRT_SECURE_NO_WARNINGS//解决在vs2022中scanf不安全的问题
#include <stdio.h>

int func(int x) {
	if (x < 5) {
		return x;
	}
	else if (x >= 5 && x < 15){
		return x + 6;
	}
	else {
		return x - 6;
	}
}

int main() {

	int x;

	while (scanf("%d", &x) != EOF){		//输入x的值
		printf("y = %d\n\n", func(x));	//通过函数计算y的值并输出
	}
	
	return 0;
}
```

- 运行结果

  ![](images/1.png)

- 收获
  - 用`while (scanf("%d", &x) != EOF)`这种方式实现无限读入，但是`scanf`会涉及缓冲区问题，后面可能有坑
  - `#define _CRT_SECURE_NO_WARNINGS`加一行宏定义解决`scanf`在vs中的不安全问题

## 第二题

```c++
#define _CRT_SECURE_NO_WARNINGS//解决在vs2022中scanf不安全的问题
#include <stdio.h>

char func(char c) {
	return c - 32;
}

int main() {

	char c;

	while (scanf("%c", &c) != EOF) {				  //输入小写字母 
		getchar();									//读出每次缓冲区的换行
		printf("%c对应的大写字母是%c\n\n", c, func(c));	 //通过函数转换为大写字母并输出
	}
	return 0;
}
```

- 运行结果

![](images/2-1.png)

- 收获

  - 解决了`vs2022`控制台输出中文乱码的问题，但是设置的编码格式是简体中文936，**后面不知道会不会出问题**
  
  - 了解了`scanf`缓冲区机制（这里其实算一个大坑）
    - 特别是使用`scanf`读取单个字符时需要特别注意，因为这里不会忽略前导空白符（c语言的前导空白符一般包括：空格符，制表符，换行符）
    - ![](images/2-2.png)
      - 这里可以联想到408的读者写者问题

  - 用`while (scanf("%c", &c) != EOF)`这种方式实现一个个循环读取字符时确实有坑，因为在这里`scanf`读取的是字符，在控制台输入的换行也会随之读入，造成输出结果和预期不符合

    - 解决办法：用`getchar()`函数把每一次输入的换行符读掉即可，谨慎用`scanf(" ");`代替`getchar()`会有意想不到的结果

    - 不好的解决办法
  
      ```cc
      while (scanf(" %c", &c) != EOF) {				   //输入小写字母 
      	getchar();									//读出每次缓冲区的换行
      	printf("%c对应的大写字母是%c\n\n", c, func(c));	//通过函数转换为大写字母并输出
      }
      ```
  
      - 这种方法在`scanf()`中加一个空格，可读性太差，属实是自己坑自己

- 参考：https://blog.csdn.net/u011499425/article/details/52606973

## 第三题

```c++
#define _CRT_SECURE_NO_WARNINGS//解决在vs2022中scanf不安全的问题
#include <stdio.h>

const int N = 3;

int func(int (*a)[N]) {

	int temp = 0;
	for (int i = 0; i < N; ++i) {
		for (int j = 0; j < N; ++j) {
			if (i == j) {
				temp += a[i][j];//筛选出对角线元素，进行相加
			}
		}
	}
	return temp;
}
int main() {

	int a[N][N];

	printf("请输入一个%d行%d列的二维数组:\n", N, N);

	for (int i = 0; i < N; ++i) {
		for (int j = 0; j < N; ++j) {
			scanf("%d", &a[i][j]);//注意这里不要忘记加取地址符号
		}
	}
	//a是二维数组的首地址
	//其实可以理解为指向一片连续的区域，这片连续的区域
	// 逻辑上是二维的，实际上也是一维进行存储的
	int ans = func(a);
					  
	printf("该矩阵对角线元素之和为：%d", ans);
	return 0;
}
```

- 运行结果

<img src="images/3.png" style="zoom:80%;" />

- 收获
  - 复习了一维数组和二维数组作为函数的参数问题
  - 简单理解，不管是一维数组和二维数组，**数组的名字都是一个地址**，不用搞那么复杂，就是指向一片连续空间的地址，只不过一维数组名用一位的角度去解释这篇连续的地址空间，二维数组名用二维的角度去解释这片连续的空间（二维数组以及更高维度的数组，都是逻辑上是高维的，实际存放还是一维度的）
  - 有关形参的书写
    - 实参是`int`型一维数组名，则形参为`int *a` 或者`int a[]`，有时根据需要，还需要把数组长度进行传递
    - 实参是`int`型二维数组名，则形参为`int (*a)[对应数组的列标最大值]`或者`int a[][对应数组的列标最大值]`（因为二维数组默认是按行存储的，必须指明列这个维度，才能结合数组名去存取数据）
- 参考：https://www.cnblogs.com/Anker/archive/2013/03/09/2951878.html

## 第四题

```c++
#define _CRT_SECURE_NO_WARNINGS//解决在vs2022中scanf不安全的问题
#include <stdio.h>

int main() {

	printf("100-999的所有水仙花数为：");
	for (int i = 100; i <= 999; ++i) {
		int bw = i / 100 % 10;//获取三位数的百位
		int sw = i / 10 % 10; //获取三位数的十位
		int gw = i % 10;	  //获取三位数的各位
		if (bw * bw * bw + sw * sw * sw + gw * gw * gw == i) {
			printf("%d ", i);
		}
	}
	
	return 0;
}
```

- 运行结果<img src="images/4.png" style="zoom: 80%;" />

- 收获
  - 就是暴力搜索+条件筛选，关键是利用c语言的除法和去模运算把数字一位位的拆开

## 第五题

```c++
#define _CRT_SECURE_NO_WARNINGS//解决在vs2022中scanf不安全的问题
#include <stdio.h>

int main() {

	printf("请输入百分制成绩：");
	
	int score = 0;
	while (scanf("%d", &score) != EOF) {
		if (score >= 90 && score <= 100) {
			printf("%d对应的等级为A(优秀)\n\n", score);
		}
		else if (score >= 80 && score <= 89) {
			printf("%d对应的等级为B(良好)\n\n", score);
		}
		else if (score >= 70 && score <= 79) {
			printf("%d对应的等级为C(中等)\n\n", score);
		}
		else if (score >= 60 && score <= 69) {
			printf("%d对应的等级为D(合格)\n\n", score);
		}
		else {
			printf("该成绩不合格\n\n");
		}
		printf("请输入百分制成绩：");
	}
	
	return 0;
}
```

- 运行结果

  <img src="images/5.png" style="zoom:67%;" />

- 收获
  - 就是分支结构，顺便复习了`switch`分支结构，不过`switch`结构不常用

## 第六题

```c++
#define _CRT_SECURE_NO_WARNINGS//解决在vs2022中scanf不安全的问题
#include <stdio.h>

int func(int num) {
	
	if (num == 0) {
		return 1;
	}
	else if (num == 1) {
		return 1;
	}
	else {
		int temp1 = 1;
		int temp2 = 1;
		int temp3 = 0;
		for (int i = 2; i <= num; ++i) {
			temp3 = temp1 + temp2;
			temp1 = temp2;
			temp2 = temp3;
		}
		return temp3;
	}
}

int main() {

	int num;
	printf("请输入斐波那契的项数：");

	while (scanf("%d", &num) != EOF) {
		
		printf("第%d项对应的斐波那契为：%d\n\n", num, func(num));

		printf("请输入斐波那契的项数：");
	}

	return 0;
}
```

- 运行结果

  <img src="images/6.png" style="zoom:67%;" />

- 收获
  - 回顾了常见的三种斐波那契的解决方法
    - 利用递归
      - 优点：代码简洁，容易书写
      - 缺点：项数不易过大，否则可能爆栈，且没有记忆功能
    - 利用循环迭代交替变量
      - 优点：时间复杂度和空间复杂度都是非常低的
      - 缺点：代码不易输出，代码可读性较差，且没有记忆功能
    - 利用数组记忆
      - 优点：代码非常容易书写，而且非常容易理解
      - 缺点：因为要用数组记录每一项的结果，所以空间复杂度较差

## 第七题

```c++
#define _CRT_SECURE_NO_WARNINGS//解决在vs2022中scanf不安全的问题
#include <stdio.h>
#include <stdlib.h>

const int N = 100;
void reverse(int a[], int length) {

	//第一个和最后一个元素进行交换，交换到数据长度一半的位置即可
	for (int i = 0; i < length / 2; i++){
		int temp = a[i];
		a[i] = a[length - i - 1];
		a[length - i - 1] = temp;
	}
}

int main() {

	int length;
	int a[N];

	printf("请输入数组的长度(大于等于1并且小于等于100)：");
	scanf("%d", &length);

	printf("\n请输入长度为%d的数组：", length);

	for (int i = 0; i < length; i++){
		scanf("%d", &a[i]);
	}
	reverse(a, length);

	printf("\n数组逆序的结果为：");
	for (int i = 0; i < length; i++){
		printf("%d ", a[i]);
	}
	return 0;
}
```

- 运行结果

<img src="images/7.png" style="zoom: 67%;" />

- 收获
  - 回顾了用用三个变量交换数据的操作，认识到了，数组名是一个地址，和普通的函数值传递是不同的
  - 数组名作为参数进行传递，通常数组的长度也要一起传递，便于操作

## 第八题